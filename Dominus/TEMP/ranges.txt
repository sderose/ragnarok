descr = """
range

xpointer(start-point($xpath1)/range-to($xpath2))

Simpler?
    1/4/2/3/1#24-1/4/2/2/17#5
        (# for text-node offset? or stick with /)
    1/4/2/3/1[24]-^^^#5 (avoid re-specifying?

    string-range?
    attributes/vales? pis? comments?
    indirection through an identified xref?
    co-located objects?
    milestone...milestone

Kinds of locations (cf order theory)
    Point (bb/b/be/ae/textoffset        ???
    Element                             (block)
    Char (is that a range?)             (block)
        Range (incl. vs. exclusive?     (interval)
            Chain                       (chain of intervals)
                Thread/trail            (reordering of intervals)

POthread?? antichain? block trail?
order semantics?
should locations be able to live in doms?
unordered elements? set vs list

https://en.wikipedia.org/wiki/Order_theory

Tasks:
    Represent any actual location
    Map from loc to rendered pos and v/v?
    Store massive number of locations and support:
        compare pos of actual scopes
        compare pos of subtended content
        x within y
        least node subtending y (
        map for export
        find next start(end)
        find all ranges intersecting x
        convert to synchronous fragments
"""

# xpointer(start-point($xpath1)/range-to($xpath2))


###############################################################################
#
class TgtType(FlexibleEnum):
    ALL = 0
    SUB = 1
    BB = 2
    AB = 3
    BE = 4
    AE = 5


###############################################################################
#
class PointVRange:
    IMMISCIBLE      = "X"
    EQUAL           = "="

    PRECEDE         = "<"
    ATSTART         = "["
    OCCUPY          = "_"
    ATEND           = "]"
    FOLLOW          = ">"


###############################################################################
# Based on Allen's interval algebra, but plus 2 for point vs. range cases.
#
class RangeVRange(FlexibleEnum):
    IMMISCIBLE      = "X"

    PRECEDE         = "<<"
    MEET            = "<["
    SEMIPRECEDE     = "<_"      # OVERLAPS
    ENDEDBY         = "<]"
    CONTAIN         = "<>"

    ATSTART         = "[["
    PREFIXES        = "[_"
    EQUAL           = "[]"      # or "=="
    PREFIXEDBY      = "[>"

    OCCUPY          = "__"
    SUFFIXES        = "_]"
    SEMIFOLLOW      = "_>"      # IS_OVERLAPPED

    ATEND           = "]]"
    METBY           = "]>"

    FOLLOW          = ">>"

for rvr in RangeVRange.values():
    if rvr == "X": continue
    if not(rvr[0] in PointVRange.values() and rvr[1] in PointVRange.values()):
        raise ValueError("Bad mnemonic in RangeVRange")


###############################################################################
#
class Location:
    """A reference to a specific object, namely a Node or char (for
    purposes here, chars can ben thought of as children of CharData Nodes.
    Should attributes also be reachable?

    What about: <p>Hello <br/><img src="foo.jpg"/><br/>, there.</p>
    """
    def __init__(self, xp:str):
        self.idValue = None
        self.path = None
        self.offset = None              # Char pos in CharData

        # Cached info
        self.nodeRef = None             # The actual leaf node
        self.tgtType:nodeName = None    # And its name (possibly #text etc)
        self.checkSum = None            # Potential to catch edits

        self.setFromXPointer(xp)

    def compareDocumentPosition(other:Location) -> int:
        pass


###############################################################################
#
class Range(Location):
    """All the data from one location to another.
    """
    def __init__(self, from:Location, to:Location):
        super().__init(from)
        self.end:Datum = Location(to)
        self.coveringElement = self.findCoveringElement().

        xprExpr1 = r"xpointer\(start-point\((.*)\)/range-to\((.*)\)\)\s*$"
        mat = re.match(xprExpr1, xpr)
        if not mat: raise ValueError(
            "Cannot parse range expression '{xpr}'.")

    def findCoveringElement(self):
        if self.nodeRef == self.end.nodeRef: return self.nodeRef
        sancs = self.nodeRef.

    def getAncs(self):
###############################################################################
#
class Chain(Range):
    """An aggregate location with multiple parts
    def __init__(self):
        self.parts:list[Range] = []
        self.isContguous:bool = False
        self.isInOrder:bool = True

